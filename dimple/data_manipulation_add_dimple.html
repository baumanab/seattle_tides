<!DOCTYPE html>
<meta charset="utf-8">
<html>

<style>
      circle.dimple-series-1 {
        fill: orange !important;
		r: 6px;
      } 
	  
    </style>
<p>
  <label for="nValue" 
         style="display: inline-block; width: 240px; text-align: right">
         date = <span id="nValue-value"></span>
  </label>
  <input type="date" value="2016-06-06" min = "2015-08-20" min = "2016-08-20" id="nValue">
</p>

<div id="chartContainer">
  <script src="/lib/d3.v3.4.8.js"></script>
  <script src="/dist/dimple.v2.1.6.js"></script>
  <script type="text/javascript" src='js/lodash.js'></script>
  <script type="text/javascript" src='js/moment.js'></script>
  <script type="text/javascript" src='js/moment-with-locales.js'></script>
  
 
  
  <script type="text/javascript">	
    
	// create svg element
	var svg = dimple.newSvg("#chartContainer", 590, 400);
    // when the input range changes update value 
	d3.select("#nValue").on("input", function() {
	  console.log(this.value);
	});     
	 
    
	  
	
	// read in data and transform Day and Level to numbers
    d3.tsv("data/tide_days.tsv", function (data) {	
	  data.forEach(function(d) {
        d.Day = +d.Day;
        d.Level = +d.Level;
      });
	
	  // assign data to value of user form input
	  var date = nValue.value	
	
	  // convert user date input to day of year (0-366)	
	  var user_date = new moment(date);
	  var day_year = user_date.format('DDDD');
	  console.log(day_year);
	
	  // get nearest n days of year
	  
	  // extract unique days into array, note that dimple changes
	  // the values back to strings
	  var unique_days = dimple.getUniqueValues(data, "Day");
	  console.log(unique_days);
      
	  // filter for days >= user input as converted to day of year
	  // note that +d converts the string to a number 
	  var days_filter = unique_days.sort()
		.filter(function(d) {return +d >= day_year
		});
	  console.log(days_filter);
	  
	  // get n days of year from user input as converted to day of year
	  
	  n_days = 4;
	  
	  var the_days = days_filter.slice(0,n_days);
	  console.log(the_days);
	  
	  
	
      // Filter for a single day of year 
      data_day = dimple.filterData(data, "Day", day_year);
	  // Filter single day data for start and hike completion attributes
	  data_startstop = dimple.filterData(data_day,"start_stop",["earliest_start","latest_start","complete_hike"]);
	  console.log(data_day[0].Time);
	  console.log(data_startstop);	  
	 
	  
	  
	  // filter data for times bound by earliest start and 1 hour beyond latest start
	  
	  // ref code remove in final version but archive
	  //filtered = data_day.filter(function (d) {return d.Time === "15:00:00"});
	  //console.log(filtered);
	  //var dt = data_day.filter(function (d){return d.DateTime});
	  //console.log(dt)
	  
	  
	  // convert start times from string to datetime object
	  // these values will ultimately be used to draw vertical lines
      // and to slice the single day data	  
	  start_dt = data_startstop[0].DateTime;	  
	  console.log(start_dt);
	  // get the index
	  var start_index = data_day.map(function(d) {return d.DateTime})
		.indexOf(start_dt);
	  console.log(start_index);
	  
	  stop_dt = data_startstop[1].DateTime;	  
	  console.log(stop_dt);	
	  // get the index
	  var stop_index = data_day.map(function(d) {return d.DateTime})
		.indexOf(stop_dt);
	  console.log(stop_index);

      complete_dt = data_startstop[2].DateTime;
      console.log(complete_dt);
	  // get the index
	  var complete_index = data_day.map(function(d) {return d.DateTime})
		.indexOf(complete_dt);
	  console.log(complete_index);	  
	  
	  
	  // parse/format hike bounds strings to datetime objects	  
	  var dt_parser = d3.time.format("%Y-%m-%d %H:%M:%S");
	  var start_dt_parsed = dt_parser.parse(start_dt);
	  var stop_dt_parsed = dt_parser.parse(stop_dt);
	  console.log(start_dt_parsed);
	  console.log(stop_dt_parsed);
	  
	  // calculate latest hike completion time (1 hour from latest start)
	  // this value is available in the data set extract as the third element
	  // but I have decided to calculate it
	  var extended = d3.time.hour.offset(stop_dt_parsed,1);
	  console.log(extended);	  
	 
      // slice data bound by earliest start and 1 hour beyond latest start (complete hike), inclusive
	  var bounds = data_day.slice(start_index,complete_index + 1);
	  console.log(bounds);
	  
	  // Create and Position a Chart
      var myChart = new dimple.chart(svg);
      myChart.setBounds(60, 30, 500, 300);
      var x = myChart.addTimeAxis("x", "DateTime","%Y-%m-%d %H:%M:%S","%H:%M");
      myChart.addMeasureAxis("y", "Level");
	  
	  // Draw a label for each hour
	  x.timePeriod = d3.time.hours;
      x.timeInterval = 1;	  
      

      // Add a thick line without markers
      var lines = myChart.addSeries(null, dimple.plot.line); 
      lines.lineWeight = 3;
      lines.lineMarkers = false;	  
	  
	  // Link the date selected data
	  lines.data = data_day;
	  
	  // Add bubbles for start and hike completion values
	  //var bubble_startstop = myChart.addSeries(null,dimple.plot.bubble);
	  
	  // Link the start_stop selected data
	  //bubble_startstop.data = data_startstop;
	  
	  // plot the earliest start and complete hike bound data as line
	  var bounds_line = myChart.addSeries("Hike Window",dimple.plot.line);
	  bounds_line.lineWeight = 5;
	  bounds_line.lineMarkers = false;
	  myChart.assignColor = ("Hike Window","red")
	  
	  // link the bounds data to the bounds line series
	  bounds_line.data = bounds;
	  
	  // create a title
      d3.select('body').append('h2').text('Carkeek to Golden Gardens Hike Time Window for ' + date);
	  
	  myChart.addLegend(200, 10, 360, 20, "right");
      // Draw the chart
      myChart.draw();
	  
	  // draw vertical lines for start and hike completion values
	  // using dt objects calculated above
	  
	  svg.append("line")
	    .attr("id", "start_line")
	    .attr("class","marker_line")
        .attr("x1", x._scale(start_dt_parsed)) // this line uses calculate dt values
        .attr("x2", x._scale(start_dt_parsed)) // this line uses calculate dt values
        .attr("y1", myChart._yPixels())
        .attr("y2", myChart._yPixels() + myChart._heightPixels())
        .style("stroke", "red")
        .style("stroke-dasharray", "3");
	
	  svg.append("line")
	    .attr("id", "stop_line")
	    .attr("class","marker_line")
        .attr("x1", x._scale(stop_dt_parsed)) // this line uses calculate dt values
        .attr("x2", x._scale(stop_dt_parsed)) // this line uses calculate dt values
        .attr("y1", myChart._yPixels())
        .attr("y2", myChart._yPixels() + myChart._heightPixels())
        .style("stroke", "red")
        .style("stroke-dasharray", "3");
	
	  svg.append("line")
	    .attr("id", "complete_line")
	    .attr("class","marker_line")
        .attr("x1", x._scale(extended)) // this line uses calculate dt values
        .attr("x2", x._scale(extended)) // this line uses calculate dt values
        .attr("y1", myChart._yPixels())
        .attr("y2", myChart._yPixels() + myChart._heightPixels())
        .style("stroke", "red")
        .style("stroke-dasharray", "3");
	
	});
  </script>
</div>
</html>
